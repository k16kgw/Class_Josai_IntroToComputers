# 半加算器・全加算器・減算器

到達目標
- 数値演算の基本である加算回路，減算回路の組合せ回路での構成を理解する．
- **半加算器（HA）／全加算器（FA）** の真理値表・論理式・回路構成を説明できる．
- **リップルキャリー加算器（RCA）** をnビットに拡張して構成できる．
- **減算** を補数（2の補数）または **減算器** で実現できる．**借位/桁上げ/オーバフロー** の扱いを説明できる．
<!-- - 簡単な**最適化**（XORの合成，共通サブ式の再利用，NAND実装）を行える． -->

今日の問い
- 1ビットの加算はどの論理で表現され，どのようにnビットへ拡張するか？
- 減算は“引く”より“足す（補数化）”のが楽なのはなぜ？
<!-- - 符号（2の補数表現）の加算で **オーバフロー** はどう検出する？ -->

キーワード
- 半加算器（HA），全加算器（FA）
- リップルキャリー（RCA），キャリー生成/伝搬
- 減算，2の補数，オーバフロー
<!-- - XOR，NAND–NAND実装 -->

## 前回の復習

- クワイン・マクラスキー法に基づく，主加法標準形からNAND–NAND回路実装への流れ．
- ドントケア（0,1のどちらでも良い項）を用いて，論理式をより簡略化することが可能になる．

```{note}
**第5回演習3**

次の真理値表で定義される論理式$G'$の簡略化された論理式をクワイン・マクラスキー法を用いて導出せよ．

| A | B | C | D | $G'(A,B,C,D)$ |
|:-:|:-:|:-:|:-:|:-:|
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 0 |
| 0 | 0 | 1 | 0 | 0 |
| 0 | 0 | 1 | 1 | 1 |
| 0 | 1 | 0 | 0 | ＊ |
| 0 | 1 | 0 | 1 | 1 |
| 0 | 1 | 1 | 0 | 1 |
| 0 | 1 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | ＊ |
| 1 | 0 | 1 | 1 | 0 |
| 1 | 1 | 0 | 0 | ＊ |
| 1 | 1 | 0 | 1 | 1 |
| 1 | 1 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 |
```

## 半加算器（Half Adder, HA）

$A,B$が$0,1$のとき，$A+B$の2進表示は次のようになる．

| $A$ | $B$ | $A+B$ |
| :-: | :-: | :---: |
|  0  |  0  |   0   |
|  0  |  1  |   1   |
|  1  |  0  |   1   |
|  1  |  1  |  10   |

この結果を2の位と1の位との2つの出力として扱う．

### 定義と真理値表

- 入力：$A,B$（1ビット）
- 出力：桁上げ$C$ (carry)，和$S$ (sum)

| $A$ | $B$ | $C$ | $S$ |
| :-: | :-: | :-: | :-: |
|  0  |  0  |  0  |  0  |
|  0  |  1  |  0  |  1  |
|  1  |  0  |  0  |  1  |
|  1  |  1  |  1  |  0  |

- 論理式
  - $C=A \cdot B$
  - $S = A \oplus B = \overline{A} \cdot B + A \cdot \overline{B}$
- これを実現する回路を<span style="color:red">半加算器</span>と呼ぶ．

```{tip}
**例**

1. 上の真理値表から$C$，$S$を出力する回路図をXOR回路とAND回路を用いて作成せよ．
2. **NANDのみ** で半加算器を構成する回路図を作成せよ．

![例1-1](/contents/figs/6/eg1-1.png)

$C$, $S$の主加法標準形から

$$
C = A \cdot B = \overline{\overline{A \cdot B}}
$$

$$
S &= \overline{A} \cdot B + A \cdot \overline{B}
\\
&= \overline{\overline{\overline{A} \cdot B + A \cdot \overline{B}}}
\\
&= \overline{\overline{\overline{A} \cdot B} \cdot \overline{A \cdot \overline{B}}}
$$

![例1-2](/contents/figs/6/eg1-2.png)

しかしながら，この回路は次の変形からより簡潔な回路図を作成できる．

$$
S &= \overline{A} \cdot B + A \cdot \overline{B}
\\
&= \overline{B} \cdot B + \overline{A} \cdot B + A \cdot \overline{B} + A \cdot \overline{A}
\\
&= (\overline{B}+\overline{A}) \cdot B + A \cdot (\overline{A}+\overline{B})
\\
&= \overline{\overline{(\overline{B}+\overline{A}) \cdot B + A \cdot (\overline{A}+\overline{B})}}
\\
&= \overline{\overline{((\overline{B}+\overline{A}) \cdot B)} \cdot \overline{(A \cdot (\overline{A}+\overline{B}))}}
\\
&= \overline{\overline{(\overline{A \cdot B}) \cdot B} \cdot \overline{A \cdot (\overline{A \cdot B})}}
$$

![例1-3](/contents/figs/6/eg1-3.png)
```

回路図では半加算器は次のように簡易的に表示する．

![半加算器](/contents/figs/6/ha.png)

## 全加算器（Full Adder, FA）

ある桁における和を考える場合，下の桁からの桁上がりも考慮する必要が出てくる．

$A$と$B$との和において，下からの桁上がりを$C_{in}$として，和を$S$，上の桁への桁上がりを$C_{out}$とする．

### 定義と真理値表

- 入力：$A,B,C_{in}$
- 出力：桁上げ$C_{out}$，和$S$

| $A$ | $B$ |$C_{in}$|$C_{out}$| $S$ |
| :-: | :-: | :---:  | :---:   | :-: |
|  0  |  0  |   0    |   0     |  0  |
|  0  |  0  |   1    |   0     |  1  |
|  0  |  1  |   0    |   0     |  1  |
|  0  |  1  |   1    |   1     |  0  |
|  1  |  0  |   0    |   0     |  1  |
|  1  |  0  |   1    |   1     |  0  |
|  1  |  1  |   0    |   1     |  0  |
|  1  |  1  |   1    |   1     |  1  |

- 論理式：
  - $C_{out} = A \cdot B + C_{in} \cdot (A\oplus B)$
  - $S = A \oplus B \oplus C_{in}$
- 構成：
  - 半加算器の出力として$A \cdot B$と$A \oplus B$が出力されるので，半加算器とOR回路のみを用いて回路図を作成することができる．
- これを実現する回路を<span style="color:red">全加算器</span>と呼ぶ．

```{tip}
**例**

1. 全加算器の回路図をAND, OR, XOR回路を用いて作成せよ．
2. 全加算器の回路図を，半加算器とOR回路のみを用いて作成せよ．

![例2-1](/contents/figs/6/eg2-1.png)

![例2-2](/contents/figs/6/eg2-2.png)
```

回路図では全加算器は次のように簡易的に表示する．

![全加算器](/contents/figs/6/fa.png)

## nビット加算：リップルキャリー加算器（RCA）

- $i$桁目の計算による桁上げを$C_{out,i}$とし，$i$桁目の計算で考慮すべき下の桁からの桁上げを$C_{in,i}$とおく．

- **構成**：全加算器を直列にn個配置し，$C_{out,i}$が次段の$C_{in,i+1}$へ“リップル (ripple)”するように接続する．

※ ripple：波紋を広げる．

<!-- 
- **遅延**：最悪 (O(n))．最下位から最上位へキャリーが伝搬．
- **改良の入口**（紹介）：キャリー先読み（CLA）で (O(\log n)) へ短縮（生成/伝搬 (G_i=A_iB_i), (P_i=A_i\oplus B_i)）．
 -->

```{tip}
**例**

1. 4ビットリップルキャリー加算器の回路図（FA×4）を作成せよ．

![4ビットリップルキャリー加算器](/contents/figs/6/rca.png)
```

```{note}
**演習1**

$A=0111, B=0101, C_{in}=0$のときの出力，5桁目への桁上げ$C_{out}$と各位$S_{i}$を求めよ．
```

## 減算の実現

### 減算器の基本

<!-- - 1ビット減算 $D = A - B$．出力：差 $D$，借位 $B_{out}$． -->
**加算器を流用** して減算を実装する．

### 2の補数による減算

- 2の補数：$-B = \overline{B} + 1$（ビット反転＋1）．
- $A - B = A + (\overline{B} + 1)$．
- **実装**：
  - $B$を **全ビット反転** し，最下位の桁上げを$C_{in}=1$としてリップルキャリー加算器に入力する．
  <!-- - 制御信号 $SUB\in{0,1}$ を用い，$SUB=1$ のとき **XOR** で (B) を反転，$C_{in}=SUB$． -->
<!-- 
```{tip}
**演習3**

- 制御信号 $SUB$ を使って "加算/減算" を1本のRCAで切替える**加減算器**のブロック図を描け：
  - 各ビットで $B_i' = B_i \oplus SUB$．
  - 最下位 $C_{in}=SUB$．
```
 -->

 ```{note}
**演習2**

4ビット減算器の回路図（FA×4）を作成せよ．

![4ビット減算器](/contents/figs/6/rcd.png)
```
<!-- 
### オーバフローとキャリー

- **符号なし**：最終キャリー $C_{out,n}$ が 1 なら桁あふれ．差分でも借位を同様に扱う．
- **2の補数（符号付き）**：最上位ビットへの**入力キャリー**と**出力キャリー**が異なると**オーバフロー**．
  - 判定：$OV = C_{n-1\to n}^{in} \oplus C_{n-1\to n}^{out}4．

```{note}
**演習2**

- 4ビットでの2の補数で $A=0111(7), B=1001(-7)$ を加算．$OV$ を計算して結果を解釈せよ．
```
 -->

## 加減算器

 ```{note}
**演習3**

全加算器4つと，必要に応じて基本的な回路を使用して加算と減算を実現する回路図を作成せよ．

ヒント：最下位の$C_{in}$が$0$なら加算器，$1$なら減算器となるように回路を組む．

![4ビット減算器](/contents/figs/6/rcad.png)
```

<!-- 
## 5. 実装最適化の小ネタ（後半その2）

- **XORの共有**：(X=A\oplus B) を1回だけ合成し，(S) と (C_{out}) 両方で使う．
- **NAND–NAND**での実装：

  - XOR は NAND/NOR の組み合わせで作成（演習1参照）．
  - 反転は (\mathrm{NAND}(X,X)) で共有．ファンイン上限に合わせて分割．
- **配線と遅延**：RCAは配線が素直で学習用に最適．速度が重要ならCLAやCSKAを概説．

```{tip}
**例4**
- 1ビットFAの式から**NANDゲートのみ**で実装スケッチを描け．XORを2個どう配置するかがポイント．
```
 -->

## まとめ

- 1ビット加算の本質：$S=A\oplus B\oplus C_{in}$，$C_{out}=A \cdot B + C_{in} \cdot (A\oplus B)$．
- nビット加算：FAの直列（RCA）．
- 減算：2の補数化で加算器を流用．
<!-- - オーバフロー検出：符号なしは最終キャリー，符号付きは$OV = C_{in}^{MSB}\oplus C_{out}^{MSB}$． -->

```{note}
**復習**

1. 半加算器と全加算器の違いを述べよ．
<!-- 2. 4ビットリップルキャリー加算器で$A=1011, B=1101, C_{in}=0$ の和$S$と最終キャリー$C_{out}$を計算せよ． -->
<!-- 3. 2の補数のオーバフロー条件を述べよ． -->
```
<!-- 
## 付録：式の導出メモ

- FAの式導出（SOP）

  - (S) は3入力XOR：ミン項 (\sum m(1,2,4,7))．
  - (C_{out}) は (\sum m(3,5,6,7)) → (AB + AC_{in} + BC_{in} = AB + C_{in}(A\oplus B))．
- XORのSOP：(A\oplus B=\overline{A}B + A\overline{B})．
- 2の補数：(\text{neg}(B)=\overline{B}+1)．最下位キャリーに1を注入する理由． 
 -->
