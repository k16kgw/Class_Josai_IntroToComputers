# 乗算回路，除算回路

到達目標
- **順序回路**（シフト＋加減算＋制御）による**乗算・除算**の実現方法を説明できる．
<!-- - **順序回路**（シフト＋加減算＋制御）と**組合せ回路**（配列・圧縮木など）による**乗算／除算**の実現方法を説明できる． -->
<!-- - 4〜8ビット規模で**逐次型乗算器／除算器**の**データパス＋制御**（FSM）を設計できる． -->
<!-- - 代表的な上位手法（**Booth**, **配列乗算器**, **SRT**, **逆数反復**）の狙いを概要説明できる． -->

今日の問い
- なぜ「シフト＋加減算」で乗算・除算ができるのか？
<!-- - 面積と速度をどうトレードオフする？ -->
<!-- - 符号付き（2の補数）では何が変わる？ -->

<!-- キーワード
- shift-and-add / shift-and-subtract
- restoring / non-restoring 除算，SRT，Newton–Raphson -->
<!-- - アキュムレータ（ACC），シフトレジスタ（SR），カウンタ（CNT） -->
<!-- - 配列乗算器，Booth，Wallace/Dadda 圧縮木 -->

---

## 授業アンケート

WebClassのリンクから回答

## レジスタ

データを一時的に記憶するための回路．

種類
- 汎用レジスタ：算術演算や論理演算の入力や出力結果を一時的に記憶．
- フラグレジスタ：演算結果に関する属性（符号・オーバーフローなど）を記憶．条件分岐などで参照する．
- スタックポインタ：スタック領域を指示．（スタック：データを一時的に詰める場所）
- プログラムカウンタ：次に実行する命令が格納されているアドレスを指示．
- 命令レジスタ：メモリから読み出した現在実行中の命令を記憶．
- メモリアドレスレジスタ：これからアクセスするメモリのアドレスを指示．
- メモリデータレジスタ：メモリからCPUへ流すデータを一時的に記憶．

![演算](/contents/figs/11/computer.png)

※ ALU（Arithmetic and Logic Unit，算術論理演算器）は演算を行う回路．

基本的な4ビットのレジスタは次のように実装される．

![レジスタ回路](/contents/figs/11/register.png)

## 2のべき乗を掛ける／割る

- ビットシフトの意味
  - 左に1桁シフト：$\times 2$
  - 右に1桁シフト：$\div 2$
  - cf. 10進数だったら左に1桁シフトは10倍，右に1桁シフトは1/10倍に相当する．
  - cf. N進数での1桁シフトはN倍／1/N倍に相当する．

- 2のべき乗
  - 左にn桁シフト：$\times 2^n$
  - 右にn桁シフト：$/(2^n)$

---

## 乗算

### 一桁の乗算

| A | B | $A$と$B$の積 |
| - | - | ----------  |
| 0 | 0 |     0       |
| 0 | 1 |     0       |
| 1 | 0 |     0       |
| 1 | 1 |     1       |

1bitの$A$と$B$の積は$A \cdot B$に等しい．

### 逐次型（shift-and-add：加算＋シフト）

```{note}
**演習1**

2進数の2つの数$1011$と$101$との積を次の2つの方法で計算し，値が一致することを確認せよ．

- 一桁の乗算の結果を参考に，筆算を用いて計算する．
- 10進数に直して乗算を計算し，2進数に戻す．
```

```{note}
**演習2**

前演習1の筆算の手続きを参考に，2bitの数$A_1 A_0$と$B_1 B_0$との積を実装する回路を考えよ．

<!-- 
![2by2](/contents/figs/12/2by2.png)
 -->
```

<!-- 4bit同士の乗算では -->

<!-- 
#### 符号付き（2の補数）

- そのままでは負値の部分積調整が必要→**Booth法**で連続1をまとめ，符号も自然に扱う（後述）．
 -->
<!-- 
### 組合せ型（並列）：配列乗算器＆圧縮木

**配列乗算器（array multiplier）**

- 各ビットの **部分積 (A\cdot B_i\ll i)** を**同時生成**し，行列状に加算．
- ブロック図：`/contents/figs/12/mul_array.png`
- レイテンシ短（1〜数段）が，配線・面積は大．

**圧縮木（Wallace / Dadda）**

- 部分積ビット列を**3:2 圧縮（フル加算器）**で木状に畳む → 2列へ → 最終加算器．
- ブロック図：`/contents/figs/12/mul_wallace.png`
- 速度◎（段数 (\approx O(\log n))），設計は複雑．

**Booth（修正Booth）**

- 乗数のビット列を 1/−1/±2 などに「再符号化」→ **部分積数の削減**＋**符号の自然処理**．
- 逐次型/並列型どちらにも適用可能．
 -->

---

## 除算

### 逐次型（長除法：shift-and-subtract）

```{note}
**演習3**

2進数の計算$1011 \div 11$を次の2つの方法で計算し，値が一致することを確認せよ．

- 筆算を用いて計算する．
- 10進数に直して計算し，2進数に戻す．
```

上位から1ビットずつ降ろし，**引けるか判定**して商ビットを立てる．

**restoring法**（復元法）
1. 余り$R$を左シフトし，被除数の次ビットを取り込む．
2. $R\leftarrow R - D$とする．
3. $R$の符号によって次のいずれかを行う．
   - $R\ge 0$ならば商bitは1のまま．
   - $R<0$なら商bitは0にして$R\leftarrow R + D$として**復元**する．

この手続きを回路に実装するのは複雑なため，実用上は他のアルゴリズムに基づきソフトウェアとして実装される．

<!-- 
### 高速化の入口

- **SRT除算**：商の桁を ({-2,-1,0,1,2}) などから**桁選択**する方式（並列性↑）．
- **逆数×乗算**：浮動小数点では (1/D) を Newton–Raphson / Goldschmidt で反復近似 → **A×(1/D)**．
  乗算器が強いアーキテクチャで有利（GPU/FPGA の DSP ブロックなど）．
 -->
---
<!-- 
## 逐次型の「実装の型」：データパス＋制御

### 乗算器（逐次型）の型

- **データパス**：ACC, SR_A, SR_B, ALU(+), CNT, Z判定
- **制御（Moore FSM）**：IDLE→LOAD→LOOP{TEST, ADD, SHIFT, DEC}→DONE
- **信号**：`ACC_EN, A_SHL, B_SHR, ADD_EN, CNT_DEC, DONE` など

`/contents/figs/12/mul_sequential_fsm.png`

### 除算器（逐次型）の型

- **データパス**：REG_R, REG_Q, REG_D, ALU(±), CNT
- **制御（restoring）**：IDLE→LOAD→LOOP{SHIFT_R, SUB, TEST, (RESTORE), Q_WRITE, DEC}→DONE

`/contents/figs/12/div_sequential_fsm.png`
 -->
<!-- **設計メモ** -->

<!-- - “シフト方向”と“取り込み側”で配線がこんがらがりやすい．波形スケッチで自分に方言を作ると安定． -->
<!-- - 1クロック/1ステップで動かすか，**マルチサイクル**で加算・比較を分けるかはリソース次第． -->
<!-- 
---

## 符号付き（2の補数）の扱い

- **乗算**

  - **Booth**（もしくは修正Booth）で乗数の 0/1 連長を ±1,±2 に畳み，**負値の部分積**を自然に扱う．
  - 逐次型でも適用可：`…00`（変化なし）, `…01`（+A）, `…10`（−A）, `…11`（変化なし）等の判定．

- **除算**

  - 被除数・除数の符号を先に分離し，**絶対値で操作**→ 最後に商の符号を付与，余りは被除数の符号に合わせるのが一般的．
 -->
<!-- 
## 速度と面積のトレードオフ

| 方式                 | 面積  | レイテンシ       | スループット     | 難易度 | 典型用途             |
| ------------------ | --- | ----------- | ---------- | --- | ---------------- |
| 逐次（シフト＋加/減算）       | 小   | 大（≈n）       | 低          | 低   | 教育・小規模FPGA・省リソース |
| 配列乗算器              | 中〜大 | 小           | 中          | 中   | 固定長整数の中速実装       |
| 圧縮木（Wallace/Dadda） | 大   | 小 ($\log n$) | 高（パイプライン可） | 高   | 高速演算器・DSP        |
| SRT/反復法（除算）        | 大   | 小〜中         | 高          | 高   | 浮動小数点・高性能CPU     |
 -->
<!-- 
## 例題・演習

**例題A（設計）｜4ビット逐次乗算器**
データパス：ACC(8b), SR_A(4b), SR_B(4b), ADD, CNT．

1. ブロック図を描け．2) FSMの状態と出力制御信号を表にせよ．3) A=1011, B=0101 の動作表を1行作れ．

**例題B（設計）｜4ビット restoring 除算器**
データパス：R(5b), Q(4b), D(4b), SUB, CNT．

1. R のビット幅理由を述べよ．2) N=1101, D=0011 の1サイクル分の更新式を書け．

**演習1（Booth入門）**
乗数Bのビット列 `... b_{i+1} b_i` を見て，(b_{i+1}, b_i) が (0,1) なら `+A<<i`，(1,0) なら `-A<<i`，他は0 を加えるルールで，
A=0110, B=0111 の部分積列を列挙せよ（上位のバイアス処理は無視）．

**演習2（比較）**
同じ 8ビット乗算を，逐次型（1加算器）と配列型（部分積＋加算段）で概算ゲート数・段数を比較し，
「クロック制約」「消費電力」「配線難度」の観点で短所長所を3行でまとめよ．
 -->
---

## まとめ

- 乗算は筆算の手続きを参考に回路へ実装される．

---

## これまでのまとめ

![概要図](/contents/figs/12/machine.png)

出典「【図解】コンピュータの仕組み・構成と五大装置」https://elite-lane.com/computer/（2025年12月16日閲覧）

- ALU（演算装置）：第6回（加算と減算），第12回（乗算と除算）
- レジスタ：第10回（フリップフロップ），第12回（レジスタ）
- 制御装置：第9回（クロック・同期），第11回（順序回路の設計法）
- 物理実装（トランジスタ）：第8回（NOT・NANDの電気的動作）
- メモリ：第10回（フリップフロップ），第13回（SRAM・DRAM・Flashメモリ）
<!-- - 配線・選択（デコーダ・エンコーダ）：第8回（入出力選択・符号化） -->

<!-- - 高速化：**並列生成（部分積）＋圧縮木**，Booth/SRT/反復法で**段数 or 桁選択**を圧縮． -->
<!-- - 符号付きは **Booth**（乗算）／**符号分離→絶対値演算**（除算）が実務の型． -->
<!-- - 次回は，これらを**CPUデータパス**（ALU・レジスタファイル・制御）に統合する見取り図へ． -->
