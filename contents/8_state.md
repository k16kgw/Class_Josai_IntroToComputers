# 順序回路による状態の保持，状態遷移
<!-- 桁上げ先見回路・エンコーダ/デコーダ・MUX/DEMUX・記憶（フリップフロップ） -->

到達目標
- 桁上げ先見回路の計算時間が短くなるメカニズムを理解する．
- 桁上げ先見回路付き4ビット加算器の回路構成を実装できる．
- データの記憶（保持）の原理を理解する．
<!-- - エンコーダ（優先・BCD）とデコーダ（$n\to2^n$）の入出力関係と代表式を導ける． -->
<!-- - MUX/DEMUXの機能を理解し，MUXで任意の論理関数を実装できる． -->
<!-- - NAND/NOTを用いたラッチ（SR, D）の基本原理を説明できる． -->

今日の問い
- リップルキャリー加算器より桁上げ先見回路の方が計算速度が速くなるのはなぜか？
<!-- - エンコーダ/デコーダ・MUX/DEMUXは何を“写像”している？ -->
- NANDやNOTを使用した回路で“記憶”はどう作るのか？

キーワード
- 桁上げ先見回路
<!-- - エンコーダ，デコーダ -->
<!-- - マルチプレクサ，デマルチプレクサ -->
- フリップフロップ回路

## 第6回の復習

- 半加算器：2つの1ビットの入力の加算を計算する回路
  - 入力：$A,B$（1ビット）
  - 出力：桁上げ$C$ (carry)，和$S$ (sum)
  - $C=A \cdot B$
  - $S=A\oplus B$．

    | $A$ | $B$ | $C$ | $S$ |
    | :-: | :-: | :-: | :-: |
    |  0  |  0  |  0  |  0  |
    |  0  |  1  |  0  |  1  |
    |  1  |  0  |  0  |  1  |
    |  1  |  1  |  1  |  0  |
    
    ![半加算器](/contents/figs/6/ha.png)

- 全加算器：下の桁からの桁上がりを考慮して，2つの1ビットの入力の加算を計算する回路
  - 入力：$A,B,C_{in}$
  - 出力：桁上げ$C_{out}$，和$S$
  - $C_{out} = A \cdot B + C_{in} \cdot (A\oplus B)$
  - $S = A \oplus B \oplus C_{in}$

    | $A$ | $B$ |$C_{in}$|$C_{out}$| $S$ |
    | :-: | :-: | :---:  | :---:   | :-: |
    |  0  |  0  |   0    |   0     |  0  |
    |  0  |  0  |   1    |   0     |  1  |
    |  0  |  1  |   0    |   0     |  1  |
    |  0  |  1  |   1    |   1     |  0  |
    |  1  |  0  |   0    |   0     |  1  |
    |  1  |  0  |   1    |   1     |  0  |
    |  1  |  1  |   0    |   1     |  0  |
    |  1  |  1  |   1    |   1     |  1  |

    ![全加算器](/contents/figs/6/fa.png)

- リップルキャリー加算器

    ![4ビットリップルキャリー加算器](/contents/figs/6/rca.png)

## 桁上げ先見回路（Carry Lookahead, CLA）

リップルキャリー加算器では，ある桁の計算をするためにはそれ以下の桁での計算が完了して全ての桁上がりが判明している必要がある．
→ 桁が増えるほど計算時間が長くなる問題

桁上げ先見回路では<span style="color:red">各桁の桁上がりをあらかじめまとめて計算できる</span>ため，桁数が増えても計算スピードが長くなりにくい．

### 基本式

- 和 (sum) $S_i = A_i\oplus B_i \oplus C_i$
- キャリー (carry) $C_{i+1}=A_i\cdot B_i + (A_i\oplus B_i) \cdot C_i$

### 桁上げ先見回路付き4ビット加算器

- $C_i$：$2^i$の位の桁上げ．特に$C_0$は1なら加算器，0なら減算器になる．
- $G_i=A_i\cdot B_i$：$2^i$の位の計算で生じる桁上げ．carryの**生成**．
- $P_i=A_i\oplus B_i$：$2^i$の位での和．これに下の桁からの桁上げがかかると，その位での桁上げを生じる．carryの**伝播**．

各桁の桁上げは次のように展開できる．
- $C_1 = G_0 + P_0 \cdot C_0$ … 全加算器の桁上げそのもの
- $C_2 = G_1 + P_1 \cdot G_0 + P_1 \cdot P_0 \cdot C_0$
- $C_3 = G_2 + P_2 \cdot G_1 + P_2 \cdot P_1 \cdot G_0 + P_2 \cdot P_1 \cdot P_0 \cdot C_0$
- $C_4 = G_3 + P_3 \cdot G_2 + P_3 \cdot P_2 \cdot G_1 + P_3 \cdot P_2 \cdot P_1 \cdot G_0 + P_3 \cdot P_2 \cdot P_1 \cdot P_0 \cdot C_0$

全ての位の桁上げが分かれば，各桁の値は次で求まる．
- $S_i = P_i \oplus C_i$

```{note}
**演習1**

半加算器と基本的な回路素子を用いて桁上げ先見回路付き4ビット加算器の回路図を作成せよ．

![桁上げ先見回路付き4ビット加算器](/contents/figs/8/CLA.png)
```
<!-- 
### 実装上の視点

- ゲート段数：RCAは“段数≈ビット幅”，CLAは“段数≈対数＋定数”に近づけられる（ブロック化）．
- ファンイン制約：(P_3P_2P_1P_0) のような多入力積は実装時に**分割**が必要．

```{note}
**演習1**
1. $G_i,P_i$ の真理値表を作り，SOPを導出せよ．
2. 4ビットCLA×2で8ビット加算器を作るとき，上位ブロックの $C_4$ を“ブロック $G,P$”で書け．  
   ヒント：$G^{(blk)}=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1G_0$，$P^{(blk)}=P_3P_2P_1P_0$．
```
 -->

## エンコーダとデコーダ

<!-- ### エンコーダ（1-of-$k$ → $\lceil\log_2 k\rceil$） -->
<!-- ### エンコーダ

- 8→3エンコーダ（入力 $D_7\ldots D_0$，出力 $Y_2,Y_1,Y_0$）

  - $Y_2=D_4+D_5+D_6+D_7$
  - $Y_1=D_2+D_3+D_6+D_7$
  - $Y_0=D_1+D_3+D_5+D_7$
- 優先エンコーダ（Priority）：複数“1”時に**優先順位**を適用．VALID信号を付けるのが定石．

```{tip}
**例（8→3優先エンコーダの $Y_2$ ）**

- 最上位優先 $D_7>D_6>\dots>D_0$．  
  $Y_2 = D_7 + (\overline{D_7}D_6) + (\overline{D_7}\overline{D_6}D_5) + (\overline{D_7}\overline{D_6}\overline{D_5}D_4)$．
- VALID $= D_0+\cdots+D_7$．
``` -->

### BCDエンコーダ（10→4）

- 入力 $D_9\ldots D_0$（1-of-10），出力 $Y_3Y_2Y_1Y_0$

|$D_9$|$D_8$|$D_7$|$D_6$|$D_5$|$D_4$|$D_3$|$D_2$|$D_1$|$D_0$|$Y_3$|$Y_2$|$Y_1$|$Y_0$|
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |
|  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  1  |
|  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  1  |  0  |
|  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |  1  |  1  |
|  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |
|  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  1  |
|  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  1  |  0  |
|  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  1  |  1  |
|  0  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |
|  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  1  |

  - $Y_3=D_8+D_9$
  - $Y_2=D_4+D_5+D_6+D_7$
  - $Y_1=D_2+D_3+D_6+D_7$
  - $Y_0=D_1+D_3+D_5+D_7+D_9$

<!-- ### デコーダ（$n\to 2^n$） -->
### デコーダ（4→10）

- 入力 $Y_3Y_2Y_1Y_0$，出力 $D_9\ldots D_0$

|$Y_3$|$Y_2$|$Y_1$|$Y_0$|$D_9$|$D_8$|$D_7$|$D_6$|$D_5$|$D_4$|$D_3$|$D_2$|$D_1$|$D_0$|
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |
|  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |
|  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |
|  0  |  0  |  1  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |
|  0  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |
|  0  |  1  |  0  |  1  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |
|  0  |  1  |  1  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |
|  0  |  1  |  1  |  1  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  1  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  1  |  0  |  0  |  1  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  1  |  0  |  1  |  0  | ＊  | ＊  | ＊  |  ＊  | ＊  | ＊  |  ＊  |  ＊  | ＊  |  ＊  |
|  1  |  0  |  1  |  1  | ＊  | ＊  | ＊  |  ＊  | ＊  | ＊  |  ＊  |  ＊  | ＊  |  ＊  |
|  1  |  1  |  0  |  0  | ＊  | ＊  | ＊  |  ＊  | ＊  | ＊  |  ＊  |  ＊  | ＊  |  ＊  |
|  1  |  1  |  0  |  1  | ＊  | ＊  | ＊  |  ＊  | ＊  | ＊  |  ＊  |  ＊  | ＊  |  ＊  |
|  1  |  1  |  1  |  0  | ＊  | ＊  | ＊  |  ＊  | ＊  | ＊  |  ＊  |  ＊  | ＊  |  ＊  |
|  1  |  1  |  1  |  1  | ＊  | ＊  | ＊  |  ＊  | ＊  | ＊  |  ＊  |  ＊  | ＊  |  ＊  |

  <!-- - $Y_3=D_8+D_9$
  - $Y_2=D_4+D_5+D_6+D_7$
  - $Y_1=D_2+D_3+D_6+D_7$
  - $Y_0=D_1+D_3+D_5+D_7+D_9$ -->

<!-- - 3→8デコーダ（EN=1）：
  $Y_0=\overline{A},\overline{B},\overline{C}$, $Y_1=\overline{A},\overline{B}C$, …, $Y_7=ABC$
- EN端子で一括無効化：$Y_i = \text{EN}\cdot(\text{該当最小項})$ -->

<!-- 
## マルチプレクサ（MUX）とデマルチプレクサ（DEMUX）

### MUX（$2^n\to 1$）

- 4→1 MUX（選択 $S_1,S_0$，データ $I_0\sim I_3$）
  - $Y=\overline{S_1},\overline{S_0}I_0+\overline{S_1}S_0I_1+S_1\overline{S_0}I_2+S_1S_0I_3$

- 任意の論理関数を MUX で：選択線を**入力変数**に，データ線に**0/1**（または補助式）を固定して実現．

```{tip}
**例（MUXで関数実装）**

- $F(A,B,C)=\sum m(1,2,5,7)$ を 8→1 MUX で．  
  選択 $(A,B,C)$，データ線 $I_i$ は “1 の行だけ 1，他は 0”．  
  より省ゲートにするには $I_i$ に $A$ や $\overline{A}$ などの**単純式**を割り当てる方法も検討．
```

### DEMUX（$1\to 2^n$）

- 1→4 DEMUX（選択 $S_1,S_0$，入力 $D$）
  - $Y_0=\overline{S_1},\overline{S_0}D$, $Y_1=\overline{S_1}S_0D$, $Y_2=S_1\overline{S_0}D$, $Y_3=S_1S_0D$
- 応用：DEMUX＋固定 1/0 でデコーダを合成．

```{note}
**演習3**

1. 1→4 DEMUX を用いて 2→4デコーダを構成するブロック図を描け（EN端子付き）．  
2. 4→1 MUX だけで XOR（$A\oplus B$）を実装せよ（選択線 $A$，データ線に $B$ と $\overline{B}$ を適切に配置）．
```
 -->
## 記憶

### 電子回路でのNOTゲートの実装

- 電源（電圧$V+$）を1，アース（電圧$0$）を0と扱う．
- 入力が電圧$0$(0)であればトランジスタは上下の導線を通さず，出力は電圧$V+$(1)となる．
- 入力が電圧$V+$(1)であればトランジスタは上下の導線を通し，電源からアースへ電流が流れ，出力は電圧$0$(0)となる．

![not回路](/contents/figs/8/not.png)

### NOTゲートによる状態の記憶

![NOTゲート](/contents/figs/8/not_memory.png)

- $P=0$のとき，$Q=1$でないと矛盾
- $P=1$のとき，$Q=0$でないと矛盾
- $P=0$であれば$Q=1$が，$P=1$であれば$Q=0$が保持（記憶）される．

### NANDゲートによる状態の記憶

![NANDゲート](/contents/figs/8/nand_memory1.png)

![NANDゲート](/contents/figs/8/nand_memory2.png)

```{note}
**演習2**

1. $A,B$の全ての組み合わせに対して$P,Q$はどの値を取れば良いか考えよ．

| $A$ | $B$ | $P$ | $Q$ |
| :-: | :-: | :-: | :-: |
|  0  |  0  |     |     |
|  0  |  1  |     |     |
|  1  |  0  |     |     |
|  1  |  1  |     |     |
|  1  |  1  |     |     |

※ $(A,B)=(1,1)$のときは2通りの可能性がある．

2. 入力の値が$(A,B)=(0,1)$から$(1,1)$に変わったとき，出力$(P,Q)$の値はどうなるか．

3. 入力の値が$(A,B)=(0,0)$から$(1,1)$に変わったとき，出力$(P,Q)$の値はどうなると予想されるか．


| $A$ | $B$ | $P$ | $Q$ |
| :-: | :-: | :-: | :-: |
|  0  |  0  |  1  |  1  |
|  0  |  1  |  1  |  0  |
|  1  |  0  |  0  |  1  |
|  1  |  1  |  1  |  0  |
|  1  |  1  |  0  |  1  |

$(A,B)=(1,1)$のときは前の$(P,Q)$の状態が$(0,1)$であれば$(0,1)$を，$(1,0)$であれば$(1,0)$を保持する．

```

### 電子回路での実装

```{note}
**演習3**

NANDゲートは電子回路では次のように構成される．

![NAND](/contents/figs/8/nand.png)

これを参考にNANDゲートを用いた記憶の回路を電子回路として構成せよ．
```

<!-- 
### SRフリップフロップ

- 入力：$\overline{S},\overline{R}$，出力：$Q,\overline{Q}$
- 動作：

  - $\overline{S}=0$ で Set（$Q\gets 1$）
  - $\overline{R}=0$ で Reset（$Q\gets 0$）
  - $\overline{S}=\overline{R}=1$ で保持
  - $\overline{S}=\overline{R}=0$ は**禁止**
- 連立式：$Q=\overline{\overline{S}\cdot\overline{Q}},\ \overline{Q}=\overline{\overline{R}\cdot Q}$
 -->
<!-- 
### 4.3 Dラッチ（レベル感度・イネーブルE）

- (S=E\cdot D,\ R=E\cdot\overline{D}) をSRに供給
- E=1：透過（(Q\leftarrow D)），E=0：保持
- 次状態方程式：(Q_{next}=\overline{E},Q + E D)

```{tip}
**例（式確認）**
- Dラッチの真理値表から K-map を描き，$Q_{next}=\overline{E}\,Q + E D$ を導出せよ．
```
 -->
<!-- 
```{note}
**演習4**
1. NAND×2 の交差結合で SRラッチを描き，**禁止入力**を明記せよ．  
2. Dラッチに $D=Q\oplus T$ を与える“トグル動作（Tラッチ相当）”をスケッチせよ（T=1の時だけ反転）．
```
 -->

## まとめ

- 桁上げ先見回路：$C_{i+1}=G_i+P_i \cdot C_i$．4ビット展開で上位キャリーを**先読み**し，遅延を短縮する．
- エンコーダ/デコーダ：10進数を2進数のビットに，ビットを10進数に変換する．
- 記憶：NOTやNANDを使用して，情報を保持する回路を構成できる．

```{note}
**復習**

- リップルキャリー加算器より桁上げ先見回路の方が計算速度が速くなるのはなぜか？
<!-- - NANDを用いてデータを保持する回路では$(P,Q)=(1,1)$を保持することは現実？ -->
```

<!-- 
## 付録：発展課題（早く終わる学生向け）

- 発展1（CLAブロック化）：4ビットCLAを2段（下位・上位）に分け，上位の (C_4) を
  (C_4=G^{(blk)}*{upper} + P^{(blk)}*{upper}C_0) の形で記述せよ．
- 発展2（優先エンコーダ）：8→3優先エンコーダの (Y_1,Y_0) を，優先条件つきで最小化せよ（VALID付）．
- 発展3（MUX実装の省コスト化）：(F(A,B,C)=\sum m(0,2,6,7)) を 8→1 MUX で，データ線に単純式（(A), (B), (\overline{C}) など）を割り当ててゲート数を減らせ．
- 発展4（ハザードとレベルラッチ）：DラッチのE=1期間にグリッチが通るケースを例示し，Eのデューティ比を変えた時の影響を言語化せよ．
 -->

